import pandas as pd
import numpy as np

df = pd.read_excel("flipdata.xlsx")

#viewing the dataset
print(df.head())
print(df.info())
print(df.describe())

#checking counts of products with similar brand
value_counts = df['brand'].value_counts()
print(value_counts)

#counting the rows with "no value" in the rating column
no_rating_count = df[df['product_rating'] == 'No rating available'].shape[0]
print(f"Number of rows with 'No rating available' in the rating column: {no_rating_count}")

#how many missing values each column has
df.isnull().sum()  

#HANDLING MISSING VALUES

#1. retail price and discounted price

# Columns with missing values to impute
columns_to_impute = ['retail_price', 'discounted_price']

# Create imputed DataFrames for mean, median, and mode imputation
df_mean_imputed = df.copy()
df_mean_imputed[columns_to_impute] = df[columns_to_impute].fillna(df[columns_to_impute].mean())

df_median_imputed = df.copy()
df_median_imputed[columns_to_impute] = df[columns_to_impute].fillna(df[columns_to_impute].median())

df_mode_imputed = df.copy()
for col in columns_to_impute:
    df_mode_imputed[col] = df[col].fillna(df[col].mode()[0])

# Initialize a final DataFrame to store the best imputation for each column
df_final = df.copy()

# Function to calculate the best imputation based on minimum differences
for column in columns_to_impute:
    # Calculate absolute differences in mean, median, and standard deviation
    a1 = abs(df[column].mean() - df_mean_imputed[column].mean())
    b1 = abs(df[column].mean() - df_median_imputed[column].mean())
    c1 = abs(df[column].mean() - df_mode_imputed[column].mean())

    a2 = abs(df[column].median() - df_mean_imputed[column].median())
    b2 = abs(df[column].median() - df_median_imputed[column].median())
    c2 = abs(df[column].median() - df_mode_imputed[column].median())

    a3 = abs(df[column].std() - df_mean_imputed[column].std())
    b3 = abs(df[column].std() - df_median_imputed[column].std())
    c3 = abs(df[column].std() - df_mode_imputed[column].std())

    # Sum of differences for mean, median, and std
    a = a1 + a2 + a3
    b = b1 + b2 + b3
    c = c1 + c2 + c3

    # Choose the imputation method with the smallest difference
    min_value = min(a, b, c)
    if min_value == a:
        df_final[column] = df_mean_imputed[column]
    elif min_value == b:
        df_final[column] = df_median_imputed[column]
    else:
        df_final[column] = df_mode_imputed[column]

# Save and display the cleaned dataset
print(df_final.isnull().sum())
df_final.to_excel("flipdata.xlsx", index=False)
   
        
    
#2. brand (filling missing values with a placeholder)

df['brand'] = df['brand'].fillna('Unknown')

#3. images (dropping the rows may have a minimal impact on analysis since only 78 are affected.)

df = df.dropna(subset=['image'])

#4. description (dropping the rows may have a minimal impact on analysis since only 2 are affected.)

df = df.dropna(subset=['description'])

#5. product specifications(filling missing values with a placeholder)

df['product_specifications'] = df['product_specifications'].fillna('Not Available')

#6. product ratings(change the type into float and remove 'no available rating string' and convert it into 0)

df['product_rating'] = df['product_rating'].replace('No rating available',0)
df['product_rating'] = df['product_rating'].astype('float64')
df.info()


#HANDLING DUPLICATES

# Check for duplicates
duplicates = df.duplicated()
print("\nDuplicates:")
print(duplicates)

# Remove duplicates
df_unique = df.drop_duplicates()

# Display the DataFrame after removing duplicates
print("\nDataFrame after removing duplicates:")
print(df_unique)

#HANDLING COLUMNS NOT REQUIRED(dropping them)

df_dropped = df.drop(columns=['pid', 'overall_rating'])

#HANDLING OUTLIERS

# Calculate Q1 (25th percentile) and Q3 (75th percentile)
Q1 = df['retail_price'].quantile(0.25)
Q3 = df['retail_price'].quantile(0.75)
IQR = Q3 - Q1

# Define outlier boundaries
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter out outliers
df_filtered = df[(df['retail_price'] >= lower_bound) & (df['retail_price'] <= upper_bound)]


#1. making new column for discount percentage

df = df.assign(discount_percentage=((df['retail_price'] - df['discounted_price']) / df['retail_price']) * 100)

df[['discount_percentage','retail_price','discounted_price']].head()

#2. splitting timestamp column

df[['date', 'time', 'stamp']] = df['crawl_timestamp'].str.split(' ', expand=True, n=3)

#3. splitting category column

# Split the 'product_category_tree' column into three parts and ignore any additional segments
df[['category', 'type', 'style', 'sub_category']] = df['product_category_tree'].str.split('>>', n=3, expand=True)

# Delete the original 'product_category_tree' column
df.drop(columns=['product_category_tree'], inplace=True)
df.drop(columns=['sub_category'], inplace=True)

# Save the updated DataFrame back to Excel if needed
df.to_excel("flipdata.xlsx", index=False)

# Display the DataFrame to verify the results
print(df.head())

df = pd.read_excel("updated_dataset.xlsx")
#df_dropped = df.drop(columns=['pid', 'overall_rating','crawl_timestamp'])
# Get the unique values from the 'category' column
category_values = df['category'].unique()  

# Iterate through the unique category values
for col in category_values: 
    # Replace '[' in the 'category' column for each category value
    df['category'] = df['category'].str.replace('[', '', regex=False)

# Get the unique values from the 'category' column
category_values = df['category'].unique()  

# Iterate through the unique category values
for col in category_values: 
    # Replace '[' in the 'category' column for each category value
    df['category'] = df['category'].str.replace('"', '', regex=False)


# Specify the columns you want to drop
df.drop(columns=['pid','overall_rating','crawl_timestamp', 'stamp'], inplace=True)


#merging columns

df = pd.read_excel("flipdata.xlsx")
df['date'] = pd.to_datetime(df[['year', 'month', 'day']])
df['date'] = df['date'].dt.strftime('%Y-%m-%d')

df.drop(columns=['day', 'year', 'month'], inplace=True)
df.to_excel("flipdata.xlsx", index=False)

